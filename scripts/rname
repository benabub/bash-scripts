#!/bin/bash

# rename all tree (regular files & directories): lowercase + whitespaces -> '-'
# ignoring files and dirs, which begin with `.` | `~`
# no options and arg

#######################
# vars & functions
#######################

# var for -e option
exclude=0

# rename pattern (Perl)
RP=" s/([a-z])([A-Z])/$1-$2/g;\
	s/ /-/g; s/_/-/g;\
	y/A-Z/a-z/ "

rename_tree()
{
	# rename all subdirs in right order (from depth to cwd)
	# either it will cause "dir not exist" errors

	find . -depth -wholename "./*" -type d ! -name '.*' ! -name '~*' -print0 |
		xargs -0 -I {} echo {} | rename -d "$RP"

	# rename all regular files in a tree

	find . ! -name "." -type d \( -iname '.*' -o -iname '~*' \) -prune\
		-o -type f \( ! -iname ".*" -a ! -iname "~*" \) -print0 |
		xargs -0 -I {} echo {} | rename -d "$RP"
}

#######################
# start of program
#######################

while getopts ":e" opt; do
	case ${opt} in
	e )
		exclude=1
		;;
	\? )
		echo "Invalid option: -$OPTARG" 1>&2
		;;
	esac
done

shift $((OPTIND -1))

#######################
# logic
#######################

if [ $exclude -eq 1 ]; then

	if [ -z "$1" ]; then
		echo "Option -e requires one or more arguments" 1>&2
		exit 1
	fi

	for d in "$@"; do
		if [ ! -d "$(pwd)/$d" ]; then
			echo "Arguments should be subdirectories of CWD" 1>&2
			exit 1
		fi
		
	# TODO: action
	
	done

else
	if [ -n "$1" ]; then
		echo "Command without options requires no argument" 1>&2
		exit 1
	fi
	read -rp "Are You shure to rename the whole directory tree under '$(pwd)' (y/n?): " answer
	
	if [ "$answer" == "y" ] || [ "$answer" == "yes" ] || [ "$answer" == "Y" ] || [ "$answer" == "YES" ]; then
		echo "go"
	else
		echo "------------------------- cancelled -------------------------"
		exit 1
	fi

	# TODO: action
	
fi



















