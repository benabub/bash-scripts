#!/bin/bash

# Rename dir-tree (regular files & directories): lowercase + whitespaces -> '-'
# ignoring files and dirs, which begin with `.` | `~`
# matches existing paths and rename it with new indices
# as options: exclude || add dirs to rename

#######################
# vars
#######################

OPTION=0
MANUAL_FILES=0
MANUAL_DIRS=0
declare -i MANUAL_TOTAL
MANUAL_CURRENT=0
declare -i AUTO_TOTAL
AUTO_CURRENT=0
DRYRUN=0
SEP="_"
ANTI_SEP="-"

#######################
# functions
#######################

Show_Help() {
    cat <<EOF

USAGE:
    $(basename "$0") [--dryrun | -n] [OPTION] [DIRS...]

OPTIONS:
    --dryrun, -n
        Perform a dry run without making actual changes.
        This option must be specified first if used.

    [no more options]
        Rename the entire directory tree under the current working directory (cwd).

    --only, -o
        Rename all directory trees in the selected folders, including their names.

    --exclude, -e
        Rename the entire directory tree under the current working directory (cwd),
        excluding the selected folders and their contents.

    --files, -f
        Rename the entire directory tree under the current working directory (cwd),
        with manual renaming required for each non-ASCII filename.

    --onlyfiles, -of, -fo
        Rename all directory trees in the selected folders (including their names),
        with manual renaming required for each regular file containing non-ASCII characters.

    --excludefiles, -ef, -fe
        Rename the entire directory tree under the current working directory (cwd),
        excluding selected folders and their contents, with manual renaming required
        for each regular file containing non-ASCII characters.

    --dirs, -d
        Rename the entire directory tree under the current working directory (cwd),
        with manual renaming required for each directory containing non-ASCII characters
        in its name.

    --onlydirs, -od, -do
        Rename the entire directory tree under the current working directory (cwd),
        excluding selected folders and their contents, with manual renaming required
        for each directory containing non-ASCII characters in its name.

    --excludedirs, -ed, -de
        Rename the entire directory tree under the current working directory (cwd),
        excluding selected folders and their contents, with manual renaming required
        for each directory containing non-ASCII characters in its name.

    --both, -b
        Manually rename both files and directories with non-ASCII characters in their names.

    --onlyboth, -ob, -bo
        Rename all directory trees in the selected folders (including their names),
        with manual renaming required for each directory and file containing non-ASCII
        characters in their names.

    --excludeboth, -eb, -be
        Rename the entire directory tree under the current working directory (cwd),
        excluding selected folders and their contents, with manual renaming required
        for each directory and file containing non-ASCII characters in their names.

    --help, -h
        Show this help message.

EOF
}

# takes 1 arg: question string
Ask_Confirm() {
	echo "-----------------------"
	read -rp "$1" answer
	if [[ "$answer" =~ ^(y|yes|Y|YES)$ ]]; then
		return 0
	else
		echo "----------------- cancelled -----------------"
		return 1
	fi
}

# ask for separator: `_` (1) or `-` (2), Empty - default
Ask_Sep() {
	echo "-----------------------"
	echo "Please, choose the separator, default: {_}:"
	echo "(1): {_} ('Bla Bla' -> 'bla_bla')"
	echo "(2): {-} ('Bla Bla' -> 'bla-bla')"
	read -rp "Enter your choice (1|2|<Enter>): " answer
	if [[ "$answer" =~ ^[1-2]$ || -z "$answer" ]]; then
		if [ "$answer" = 2 ]; then
			SEP="-"
			ANTI_SEP="_"
		fi
	else
		echo "Unknown separator: $answer"
		return 1
	fi
}

Check_No_Args() {
	if [ -n "$1" ]; then
		echo "This command does not take any arguments in this mode."
		return 1
	fi
	return 0
}

# check if any arg starts with hyphen
Check_No_More_Opts() {
	for i in "$@"; do
		if [[ "$i" = -n ]] || [[ "$i" = --DRYRUN ]]; then
			echo "Please, use the --dryrun or -n option only at the beginning of the command."
			return 1
		fi
		if [[ "$i" = -* ]]; then
			echo "This command does not support additional options in this mode."
			return 1
		fi
	done
	return 0
}

Check_Arg_Presented() {
	if [ -z "$1" ]; then
		echo "This command requires one or more arguments in this mode."
		return 1
	fi
	return 0
}

Check_Subdir() {
	for d in "$@"; do
		if [ ! -d "$(pwd)/$d" ]; then
			echo "Arguments must be subdirectories of the current working directory."
			return 1
		fi
	done
	return 0
}

# takes 2 args: object path, object name
Check_Extension() {
	local path="$1"
	local name="$2"
	local regex='^.+\.[a-zA-Z0-9\-\/]+$'
	if [ -e "$path" ] && [[ "$name" =~ $regex ]]; then
		return 0
	else
		return 1
	fi
}

Show_Thinking_Animation() {
	echo "-----------------------"
	local message="$1"
	local spinner=("⠋" "⠙" "⠹" "⠸" "⠼" "⠴" "⠦" "⠧" "⠇" "⠏")
	local i=0

	tput civis # Hide the cursor
	while :; do
		printf "\r%s %s" "${spinner[i++ % ${#spinner[@]}]}" "$message"
		sleep 0.1
		# Stop animation when the parent process finishes
		kill -0 "$PPID" 2>/dev/null || break
	done
	# printf "\r\033[K" # Clear the line
	# tput cnorm # Restore the cursor
}

# takes 1 arg: old_str; echo new_str
Rename_Str() {
	local name="$1"

	# Remove all prefixes and suffixes of '-', '_', and ' '
	while [[ "$name" =~ ^[-_[:space:]] ]]; do
		name="${name#[-_ ]}"
	done
	while [[ "$name" =~ [-_[:space:]]$ ]]; do
		name="${name%[-_ ]}"
	done

	if [[ "$name" =~ .*[a-z][A-Z].* ]]; then
		# shellcheck disable=SC2001
		name=$(echo "$name" | sed "s/\([a-z]\)\([A-Z]\)/\1'$SEP'\2/g")
	fi
	name="${name// /$SEP}" # replace spaces with sep
	name="${name,,}" # lowercase
	if [ $SEP = "-" ]; then
		name="${name//_/$SEP}" # replace underscores with sep
	fi
	if [ $SEP = "_" ]; then
		name="${name//-/$SEP}" # replace hyphens with sep
	fi
	echo "$name"
}

# function to rename a file with checking if new name already exists, else renaiming with index
# handle both arg and stdin
# performs manual renaming of non-ASCII names if necessary
Rename() {

	Auto_Rename() {
		local path="$1"
		local prefix="${path%/*}"
		local name_old="${path##*/}"

		# Progress bar
		if [ $DRYRUN -eq 0 ] && [ $MANUAL_DIRS -eq 0 ] && [ $MANUAL_FILES -eq 0 ]; then
			((AUTO_CURRENT++))

		printf "\rRenaming Progress: [%-40s] %d%%" "$(printf '#%.0s' $(seq 1 $((AUTO_CURRENT * 40 / AUTO_TOTAL))))" $((AUTO_CURRENT * 100 / AUTO_TOTAL))
		[ $AUTO_CURRENT -eq $AUTO_TOTAL ] && { printf "\n"; tput cnorm; }
		fi

		if Check_Extension "$path" "$name_old"; then
			local base_name="${name_old%.*}"
			local extension="${name_old##*.}"

			base_name_new="$(Rename_Str "$base_name")"
			path_new="$prefix/$base_name_new.$extension"

			# check if the new name already exists
			if [ -e "$path_new" ]; then
				# if exists, start appending index to find a unique name
				local index=1
				while [ -e "$prefix/${base_name_new}-${index}.${extension}" ]; do
					((index++))
				done

				# rename with the new unique name
				if [ $DRYRUN -eq 1 ]; then
					echo "-----------------------"
					echo "auto-rename/extension/exist: >$path<"
					echo "mv $path $prefix/${base_name_new}-${index}.${extension}"
				else
					if ! mv "$path" "$prefix/${base_name_new}-${index}.${extension}"; then
						echo "Error renaming $path to $prefix/${base_name_new}-${index}.${extension}" >&2
					fi
				fi

			else

				# if does not exist, rename directly
				if [ $DRYRUN -eq 1 ]; then
					echo "-----------------------"
					echo "auto-rename/extension: >$path<"
					echo "mv $path $prefix/${base_name_new}.${extension}"
				else
					if ! mv "$path" "$prefix/${base_name_new}.${extension}"; then
						echo "Error renaming $path to $prefix/${base_name_new}.${extension}" >&2
					fi
				fi

			fi

		else

			name_new="$(Rename_Str "$name_old")"
			path_new="$prefix/$name_new"

			# check if the new name already exists
			if [ -e "$path_new" ]; then
				# if exists, start appending index to find a unique name
				local index=1
				while [ -e "$prefix/${name_new}-${index}" ]; do
					((index++))
				done

				# rename with the new unique name
				if [ $DRYRUN -eq 1 ]; then
					echo "-----------------------"
					echo "auto-rename/exist: >$path<"
					echo "mv $path $prefix/${name_new}-${index}"
				else
					if ! mv "$path" "$prefix/${name_new}-${index}"; then
						echo "Error renaming $path to $prefix/${name_new}-${index}" >&2
					fi
				fi

			else

				# if does not exist, rename directly
				if [ $DRYRUN -eq 1 ]; then
					echo "-----------------------"
					echo "auto-rename: >$path<"
					echo "mv $path $prefix/${name_new}"
				else
					if ! mv "$path" "$prefix/${name_new}"; then
						echo "Error renaming $path to $prefix/${name_new}" >&2
					fi
				fi

			fi
		fi
	}

	Manual_Rename() {
		local path="$1"
		local prefix="${path%/*}"
		local name_old="${path##*/}"
		local obj=""
		# save the path type as a str
		if [ -d "$path" ]; then
			obj="[DIR]"
		else
			obj="[file]"
		fi

		if [ "$MANUAL_TOTAL" -ne 0 ]; then
			percentage=$(( (MANUAL_CURRENT * 100) / MANUAL_TOTAL ))
			echo "--------- Manual Renaming: $percentage% -------------"
		fi
		((MANUAL_CURRENT++))

		if Check_Extension "$path" "$name_old"; then
			local base_name="${name_old%.*}"
			local extension="${name_old##*.}"

			read -rp "$obj $base_name: " base_name_new </dev/tty

			path_new="$prefix/$base_name_new.$extension"

			# check if the new name already exists
			if [ -e "$path_new" ]; then
				# if exists, start appending index to find a unique name
				local index=1
				while [ -e "$prefix/${base_name_new}-${index}.${extension}" ]; do
					((index++))
				done

				# rename with the new unique name
				if [ $DRYRUN -eq 1 ]; then
					echo "manual-rename/extension/exist: >$path<"
					echo "mv $path $prefix/${base_name_new}-${index}.${extension}"
				else
					if ! mv "$path" "$prefix/${base_name_new}-${index}.${extension}"; then
						echo "Error renaming $path to $prefix/${base_name_new}-${index}.${extension}" >&2
					fi
				fi

			else

				# if does not exist, rename directly
				if [ $DRYRUN -eq 1 ]; then
					echo "manual-rename/extension: >$path<"
					echo "mv $path $prefix/${base_name_new}.${extension}"
				else
					if ! mv "$path" "$prefix/${base_name_new}.${extension}"; then
						echo "Error renaming $path to $prefix/${base_name_new}.${extension}" >&2
					fi
				fi

			fi

		else

			read -rp "$obj $name_old: " name_new </dev/tty

			path_new="$prefix/$name_new"

			# check if the new name already exists
			if [ -e "$path_new" ]; then
				# if exists, start appending index to find a unique name
				local index=1
				while [ -e "$prefix/${name_new}-${index}" ]; do
					((index++))
				done

				# rename with the new unique name
				if [ $DRYRUN -eq 1 ]; then
					echo "manual-rename/exist: >$path<"
					echo "mv $path $prefix/${name_new}-${index}"
				else
					if ! mv "$path" "$prefix/${name_new}-${index}"; then
						echo "Error renaming $path to $prefix/${name_new}-${index}" >&2
					fi
				fi

			else

				# if does not exist, rename directly
				if [ $DRYRUN -eq 1 ]; then
					echo "manual-rename: >$path<"
					echo "mv $path $prefix/${name_new}"
				else
					if ! mv "$path" "$prefix/${name_new}"; then
						echo "Error renaming $path to $prefix/${name_new}" >&2
					fi
				fi

			fi
		fi
	}

	# Function to process a single file path
	Single_Path() {
		local path="$1"
		# adding prefix `./` to path when its absent
		if ! [[ "$path" =~ ^\.\/.* ]]; then
			path="./$path"
		fi
		local name="${path##*/}"

		# choosing the way of renaming: manual / auto
		if { [ $MANUAL_FILES -eq 1 ] && [ -f "$path" ] && [[ "$name" =~ [^a-zA-Z0-9[:punct:][:space:]] ]]; } || \
			{ [ $MANUAL_DIRS -eq 1 ] && [ -d "$path" ] && [[ "$name" =~ [^a-zA-Z0-9[:punct:][:space:]] ]]; }; then

			Manual_Rename "$path"
		else

			Auto_Rename "$path"
		fi
	}

	# Check if there are arguments; if yes, iterate over them
	if [ "$#" -gt 0 ]; then
		for path in "$@"; do
			Single_Path "$path"
		done
	else
		# If no arguments, read from stdin
		while IFS= read -r path; do
			Single_Path "$path"
		done
	fi
}

# sort strings by the number of '/' symbols (replacement for -depth in find command to use in pipeline)
Sort_By_Slashes() {
	# Read from stdin
	while IFS= read -r line; do
		# Count '/' symbols and print count and line
		count=$(grep -o "/" <<< "$line" | wc -l)
		echo "$count $line"
	done | sort -nr | awk '{$1=""; print substr($0, 2)}'
}

# filter paths in pipelines by RE conditions in basename
Filter_Paths_Manual_All() {
	while IFS= read -r path; do
		local name=""
		name=$(basename "$path")
		if echo "$name" | grep -qP "[[:space:]]|[[:upper:]]|[^\x00-\x7F]|$ANTI_SEP"; then
			echo "$path"
		fi
	done
}

# filter paths in pipelines by RE conditions in basename
Filter_Paths_Manual_Only() {
	while IFS= read -r path; do
		local name=""
		name=$(basename "$path")
		if echo "$name" | grep -qP "[^\x00-\x7F]"; then
			echo "$path"
		fi
	done
}

Rename_Tree() {

	# for no manual mode
	Rename_Files_And_Dirs_Auto_Include() {

		local temp_file_files
		temp_file_files=$(mktemp)
		# remove temp file on exit:
		trap 'rm -f "$temp_file_files"' EXIT

		local temp_file_dirs
		temp_file_dirs=$(mktemp)
		# remove temp file on exit:
		trap 'rm -f "$temp_file_dirs"' EXIT

		# start async animation process
		Show_Thinking_Animation "Counting items..." &
		animation_pid=$!

		find . \
-type d \( -name '.*' ! -name '.' -o -name '~*' \) -prune \
-o -type d \( -name '* *' -o -name '*[[:upper:]]*' -o -name "*$ANTI_SEP*" \) \
-print0 | xargs -0 -I {} printf '%s\n' '{}' | Sort_By_Slashes >> "$temp_file_dirs"

		find . \
-type d \( -name '.*' ! -name '.' -o -name '~*' \) -prune \
-o -type f ! \( -name '.*' -o -name '~*' \) \
-a \( -name '* *' -o -name '*[[:upper:]]*' -o -name "*$ANTI_SEP*" \) \
-print0 | xargs -0 -I {} printf '%s\n' '{}' >> "$temp_file_files"

		AUTO_TOTAL=$(( $(wc -l < "$temp_file_dirs") + $(wc -l < "$temp_file_files") ))

		# stop async animation process
		kill $animation_pid 2>/dev/null
		# finish animation process message
		echo "completed."
		tput cnorm # Restore the cursor

		while IFS= read -r line; do
			Rename "$line"
		done < "$temp_file_files"

		while IFS= read -r line; do
			Rename "$line"
		done < "$temp_file_dirs"
	}

	# for no manual mode
	Rename_Files_And_Dirs_Manual_Include() {

		local temp_file_files
		temp_file_files=$(mktemp)
		# remove temp file on exit:
		trap 'rm -f "$temp_file_files"' EXIT

		local temp_file_dirs
		temp_file_dirs=$(mktemp)
		# remove temp file on exit:
		trap 'rm -f "$temp_file_dirs"' EXIT

		# start async animation process
		Show_Thinking_Animation "Counting items..." &
		animation_pid=$!

		find . \
-type d \( -name '.*' ! -name '.' -o -name '~*' \) -prune \
-o -type f ! \( -name '.*' -o -name '~*' \) \
-print0 | xargs -0 -I {} printf '%s\n' '{}' | \
Filter_Paths_Manual_All >> "$temp_file_files"

		find . \
-type d \( -name '.*' ! -name '.' -o -name '~*' \) -prune \
-o -type d \
-print0 | xargs -0 -I {} printf '%s\n' '{}' | \
Filter_Paths_Manual_All | Sort_By_Slashes >> "$temp_file_dirs"

		MANUAL_TOTAL=$(( $(wc -l < "$temp_file_dirs") + $(wc -l < "$temp_file_files") ))

		# stop async animation process
		kill $animation_pid 2>/dev/null
		# finish animation process message
		echo "completed."
		tput cnorm # Restore the cursor

		while IFS= read -r line; do
			Rename "$line"
		done < "$temp_file_files"

		while IFS= read -r line; do
			Rename "$line"
		done < "$temp_file_dirs"
	}

	# rename all regular files in a tree
	Rename_Files_Auto_Include() {
		local temp_file
		temp_file=$(mktemp)
		# remove temp file on exit:
		trap 'rm -f "$temp_file"' EXIT

		find . \
-type d \( -name '.*' ! -name '.' -o -name '~*' \) -prune \
-o -type f ! \( -name '.*' -o -name '~*' \) \
-a \( -name '* *' -o -name '*[[:upper:]]*' -o -name "*$ANTI_SEP*" \) \
-print0 | xargs -0 -I {} printf '%s\n' '{}' >> "$temp_file"

		while IFS= read -r line; do
			Rename "$line"
		done < "$temp_file"
	}

	# rename all subdirs from depth to cwd
	Rename_Dirs_Auto_Include() {
		local temp_file
		temp_file=$(mktemp)
		# remove temp file on exit:
		trap 'rm -f "$temp_file"' EXIT

		find . \
-type d \( -name '.*' ! -name '.' -o -name '~*' \) -prune \
-o -type d \( -name '* *' -o -name '*[[:upper:]]*' -o -name "*$ANTI_SEP*" \) \
-print0 | xargs -0 -I {} printf '%s\n' '{}' | Sort_By_Slashes >> "$temp_file"

		while IFS= read -r line; do
			Rename "$line"
		done < "$temp_file"
	}

	Rename_Files_Manual_Include() {
		local temp_file
		temp_file=$(mktemp)
		# remove temp file on exit:
		trap 'rm -f "$temp_file"' EXIT

		find . \
-type d \( -name '.*' ! -name '.' -o -name '~*' \) -prune \
-o -type f ! \( -name '.*' -o -name '~*' \) \
-print0 | xargs -0 -I {} printf '%s\n' '{}' | \
Filter_Paths_Manual_All >> "$temp_file"

		MANUAL_TOTAL=$(wc -l < "$temp_file")

		while IFS= read -r line; do
			Rename "$line"
		done < "$temp_file"
	}

	Rename_Dirs_Manual_Include() {
		local temp_file
		temp_file=$(mktemp)
		# remove temp file on exit:
		trap 'rm -f "$temp_file"' EXIT

		find . \
-type d \( -name '.*' ! -name '.' -o -name '~*' \) -prune \
-o -type d \
-print0 | xargs -0 -I {} printf '%s\n' '{}' | \
Filter_Paths_Manual_All | Sort_By_Slashes >> "$temp_file"

		MANUAL_TOTAL=$(wc -l < "$temp_file")

		while IFS= read -r line; do
			Rename "$line"
		done < "$temp_file"
	}

	# no manual
	if [ $MANUAL_FILES -eq 0 ] && [ $MANUAL_DIRS -eq 0 ]; then
		echo "-----------------------"
		echo "Renaming tree: '$(pwd)'"
		Rename_Files_And_Dirs_Auto_Include
		return
	fi

	# manual renaming dirs
	if [ $MANUAL_DIRS -eq 1 ] && [ $MANUAL_FILES -eq 0 ]; then

		# start async animation process
		Show_Thinking_Animation "Automatically renaming files..." &
		animation_pid=$!
		Rename_Files_Auto_Include
		# stop async animation process
		kill $animation_pid 2>/dev/null
		# finish animation process message
		echo "completed."
		tput cnorm # Restore the cursor

		Rename_Dirs_Manual_Include
		return
	fi

	# manual renaming files
	if [ $MANUAL_FILES -eq 1 ] && [ $MANUAL_DIRS -eq 0 ]; then

		Rename_Files_Manual_Include

		# start async animation process
		Show_Thinking_Animation "Automatically renaming directories..." &
		animation_pid=$!
		Rename_Dirs_Auto_Include
		# stop async animation process
		kill $animation_pid 2>/dev/null
		# finish animation process message
		echo "completed."
		tput cnorm # Restore the cursor

		return
	fi

	# manual renaming both (files + dirs)
	if [ $MANUAL_FILES -eq 1 ] && [ $MANUAL_DIRS -eq 1 ]; then
		Rename_Files_And_Dirs_Manual_Include
	fi
}

Only() {

	Check_Dir_Name() {
		local dir="$1"
		local name="${dir##*/}"
		if [[ "$name" =~ [A-Z[:space:]_-] ]]; then
			return 0
		fi
		if [ $MANUAL_DIRS -eq 1 ] && [[ "$name" =~ [^a-zA-Z0-9] ]]; then
			return 0
		fi
		return 1
	}

	local cwd=""
	cwd=$(pwd)
	for dir in "$@"; do
		# cutting off ending `/` if presented
		[[ "$dir" =~ .*\/$ ]] && dir="${dir%/}"

		if cd "$dir"; then
			Rename_Tree
			cd "$cwd" || { echo "Failed to change directory to '$cwd'"; exit 1; }
			if Check_Dir_Name "$dir"; then
				Rename "$dir" || echo "Failed to rename '$dir'"
			fi
		else
			echo "Failed to change directory to '$dir'"
		fi
	done
}

Exclude() {
	local exclude_dirs_find=""
	local exclude_dirs_massage=""
	for pattern in "$@"; do
		# cutting off ending `/` if presented
		if [[ "$pattern" == */ ]]; then
			pattern="${pattern%/}"
		fi
		# adding prefix ./ to path when its absent
		if ! [[ "$pattern" =~ ^\.\/.* ]]; then
			pattern="./$pattern"
		fi
		exclude_dirs_find+="-o -path '$pattern' "
		exclude_dirs_massage+="'$pattern' "
	done

	rename_files_auto() {
		local str_files
		str_files="find . \
-type d \( -name '.*' ! -name '.' -o -name '~*' $exclude_dirs_find\) -prune \
-o -type f ! \( -name '.*' -o -name '~*' \) \
-a \( -name '* *' -o -name '*[[:upper:]]*' -o -name '*$ANTI_SEP*' \) \
-print0 | xargs -0 -I {} printf '%s\n' '{}'"
		eval "$str_files" | Rename
	}

	rename_dirs_auto() {
		local str_dirs
		str_dirs="find . \
-type d \( -name '.*' ! -name '.' -o -name '~*' $exclude_dirs_find\) -prune \
-o -type d \( -name '* *' -o -name '*[[:upper:]]*' -o -name '*$ANTI_SEP*' \) \
-print0 | xargs -0 -I {} printf '%s\n' '{}'"
		eval "$str_dirs" | Sort_By_Slashes | Rename
	}

	rename_files_manual() {
		local temp_file
		temp_file=$(mktemp)
		# remove temp file on exit:
		trap 'rm -f "$temp_file"' EXIT

		local str_files
		str_files="find . \
-type d \( -name '.*' ! -name '.' -o -name '~*' $exclude_dirs_find\) -prune \
-o -type f ! \( -name '.*' -o -name '~*' \) \
-print0 | xargs -0 -I {} printf '%s\n' '{}'"
		eval "$str_files" | Filter_Paths_Manual_All  >> "$temp_file"

		while IFS= read -r line; do
			Rename "$line"
		done < "$temp_file"
	}

	rename_dirs_manual() {
		local temp_file
		temp_file=$(mktemp)
		# remove temp file on exit:
		trap 'rm -f "$temp_file"' EXIT

		local str_dirs
		str_dirs="find . \
-type d \( -name '.*' ! -name '.' -o -name '~*' $exclude_dirs_find\) -prune \
-o -type d \
-print0 | xargs -0 -I {} printf '%s\n' '{}'"
		eval "$str_dirs" | Filter_Paths_Manual_All | Sort_By_Slashes >> "$temp_file"

		while IFS= read -r line; do
			Rename "$line"
		done < "$temp_file"
	}

	count_files_auto() {
		local str_files
		str_files="find . \
-type d \( -name '.*' ! -name '.' -o -name '~*' $exclude_dirs_find\) -prune \
-o -type f ! \( -name '.*' -o -name '~*' \) \
-a \( -name '* *' -o -name '*[[:upper:]]*' -o -name '*$ANTI_SEP*' \) \
-print0 | xargs -0 -I {} printf '%s\n' '{}'"
		eval "$str_files" | wc -l
	}

	count_dirs_auto() {
		local str_dirs
		str_dirs="find . \
-type d \( -name '.*' ! -name '.' -o -name '~*' $exclude_dirs_find\) -prune \
-o -type d \( -name '* *' -o -name '*[[:upper:]]*' -o -name '*$ANTI_SEP*' \) \
-print0 | xargs -0 -I {} printf '%s\n' '{}'"
		eval "$str_dirs" | wc -l
	}

	count_files_manual() {
		local str_files
		str_files="find . \
-type d \( -name '.*' ! -name '.' -o -name '~*' $exclude_dirs_find \) -prune \
-o -type f ! \( -name '.*' -o -name '~*' \) \
-a \( -name '*[! -~]*' \) \
-print"
		eval "$str_files" | Filter_Paths_Manual_Only | wc -l
	}

	count_dirs_manual() {
		local str_dirs
		str_dirs="find . \
-type d \( -name '.*' ! -name '.' -o -name '~*' $exclude_dirs_find \) -prune \
-o -type d \( -name '*[! -~]*' \) \
-print"
		eval "$str_dirs" | Filter_Paths_Manual_Only | wc -l
	}

	# no manual
	if [ $MANUAL_FILES -eq 0 ] && [ $MANUAL_DIRS -eq 0 ]; then

		echo "-----------------------"
		echo "Renaming tree: '$(pwd)' excluding dirs: $exclude_dirs_massage"

		Show_Thinking_Animation "Counting items..." &
		animation_pid=$!
		AUTO_TOTAL=$(( $(count_files_auto) + $(count_dirs_auto) ))
		kill $animation_pid 2>/dev/null
		echo "completed."

		rename_files_auto
		rename_dirs_auto
		return
	fi

	# manual renaming dirs
	if [ $MANUAL_DIRS -eq 1 ] && [ $MANUAL_FILES -eq 0 ]; then
		MANUAL_TOTAL=$(count_dirs_manual)
		rename_files_auto
		rename_dirs_manual
		return
	fi

	# manual renaming files
	if [ $MANUAL_FILES -eq 1 ] && [ $MANUAL_DIRS -eq 0 ]; then
		MANUAL_TOTAL=$(count_files_manual)
		rename_files_manual
		rename_dirs_auto
		return
	fi

	# manual renaming both (files + dirs)
	if [ $MANUAL_FILES -eq 1 ] && [ $MANUAL_DIRS -eq 1 ]; then
		MANUAL_TOTAL=$(( $(count_files_manual) + $(count_dirs_manual) ))
		rename_files_manual
		rename_dirs_manual
	fi

}

#######################
# parsing the command
#######################

case "$1" in
--dryrun | -n)
	DRYRUN=1
	shift
	;;
esac

case "$1" in
--exclude | -e)
	OPTION=1
	shift
	;;
--only | -o)
	OPTION=2
	shift
	;;
--files | -f)
	OPTION=3
	MANUAL_FILES=1
	shift
	;;
--excludefiles | -ef | -fe)
	OPTION=31
	MANUAL_FILES=1
	shift
	;;
--onlyfiles | -of | -fo)
	OPTION=32
	MANUAL_FILES=1
	shift
	;;
--dirs | -d)
	OPTION=4
	MANUAL_DIRS=1
	shift
	;;
--excludedirs | -ed | -de)
	OPTION=41
	MANUAL_DIRS=1
	shift
	;;
--onlydirs | -od | -do)
	OPTION=42
	MANUAL_DIRS=1
	shift
	;;
--both | -b)
	OPTION=5
	MANUAL_FILES=1
	MANUAL_DIRS=1
	shift
	;;
--excludeboth | -eb | -be)
	OPTION=51
	MANUAL_FILES=1
	MANUAL_DIRS=1
	shift
	;;
--onlyboth | -ob | -bo)
	OPTION=52
	MANUAL_FILES=1
	MANUAL_DIRS=1
	shift
	;;
--help | -h)
	OPTION=6
	shift
	;;
--* | -*)
	echo "Unknown option: $1"
	exit 1
	;;
esac

#######################
# logic
#######################

# no args
if [ $OPTION -eq 0 ]; then
	Check_No_More_Opts "$@" || exit 1
	Check_No_Args "$@" || exit 1
	Ask_Confirm "Are you sure you want to rename the entire directory tree under '$(pwd)'? (y/n): " || exit 1
	Ask_Sep || exit 1

	Rename_Tree

	exit 0
fi

# only
if [ $OPTION -eq 2 ]; then
	Check_No_More_Opts "$@" || exit 1
	Check_Arg_Presented "$@" || exit 1
	Check_Subdir "$@" || exit 1
	Ask_Confirm "Are you sure you want to rename all directory trees in the selected folders, including their names? (y/n): " || exit 1
	Ask_Sep || exit 1

	Only "$@"
	
	exit 0
fi

# exclude
if [ $OPTION -eq 1 ]; then
	Check_No_More_Opts "$@" || exit 1
	Check_Arg_Presented "$@" || exit 1
	Check_Subdir "$@" || exit 1
	Ask_Confirm "Are you sure you want to rename the entire directory tree under '$(pwd)', excluding the selected folders and their contents? (y/n): " || exit 1
	Ask_Sep || exit 1

	Exclude "$@"
	
	exit 0
fi

# files
if [ $OPTION -eq 3 ]; then
	Check_No_More_Opts "$@" || exit 1
	Check_No_Args "$@" || exit 1
	Ask_Confirm "Are you sure you want to rename the entire directory tree under '$(pwd)', with manual renaming required for each non-ASCII filename? (y/n): " || exit 1
	Ask_Sep || exit 1

	Rename_Tree
	
	exit 0
fi

# only + files
if [ $OPTION -eq 32 ]; then
	Check_No_More_Opts "$@" || exit 1
	Check_Arg_Presented "$@" || exit 1
	Check_Subdir "$@" || exit 1
	Ask_Confirm "Are you sure you want to rename all directory trees in the selected folders (including their names), with manual renaming required for each regular file containing non-ASCII characters? (y/n): " || exit 1
	Ask_Sep || exit 1

	Only "$@"
	
	exit 0
fi

# exclude + files
if [ $OPTION -eq 31 ]; then
	Check_No_More_Opts "$@" || exit 1
	Check_Arg_Presented "$@" || exit 1
	Check_Subdir "$@" || exit 1
	Ask_Confirm "Are you sure you want to rename the entire directory tree under '$(pwd)' (excluding selected folders and their contents), with manual renaming required for each regular file containing non-ASCII characters? (y/n): " || exit 1
	Ask_Sep || exit 1

	Exclude "$@"
	
	exit 0
fi

# dirs
if [ $OPTION -eq 4 ]; then
	Check_No_More_Opts "$@" || exit 1
	Check_No_Args "$@" || exit 1
	Ask_Confirm "Are you sure you want to rename the entire directory tree under '$(pwd)', with manual renaming required for each directory containing non-ASCII characters in its name? (y/n): " || exit 1
	Ask_Sep || exit 1

	Rename_Tree
	
	exit 0
fi

# only + dirs
if [ $OPTION -eq 42 ]; then
	Check_No_More_Opts "$@" || exit 1
	Check_Arg_Presented "$@" || exit 1
	Check_Subdir "$@" || exit 1
	Ask_Confirm "Are you sure you want to rename all directory trees in the selected folders (including their names), with manual renaming required for each directory containing non-ASCII characters in its name? (y/n): " || exit 1
	Ask_Sep || exit 1

	Only "$@"
	
	exit 0
fi

# exclude + dirs
if [ $OPTION -eq 41 ]; then
	Check_No_More_Opts "$@" || exit 1
	Check_Arg_Presented "$@" || exit 1
	Check_Subdir "$@" || exit 1
	Ask_Confirm "Are you sure you want to rename the entire directory tree under '$(pwd)' (excluding selected folders and their contents), with manual renaming required for each directory containing non-ASCII characters in its name? (y/n): " || exit 1
	Ask_Sep || exit 1

	Exclude "$@"
	
	exit 0
fi

# both
if [ $OPTION -eq 5 ]; then
	Check_No_More_Opts "$@" || exit 1
	Check_No_Args "$@" || exit 1
	Ask_Confirm "Are you sure you want to rename the entire directory tree under '$(pwd)', with manual renaming required for each directory and regular file containing non-ASCII characters in their names? (y/n): " || exit 1
	Ask_Sep || exit 1

	Rename_Tree
	
	exit 0
fi

# only + both
if [ $OPTION -eq 52 ]; then
	Check_No_More_Opts "$@" || exit 1
	Check_Arg_Presented "$@" || exit 1
	Check_Subdir "$@" || exit 1
	Ask_Confirm "Are you sure you want to rename all directory trees in the selected folders (including their names), with manual renaming required for each directory and file containing non-ASCII characters in their names? (y/n): " || exit 1
	Ask_Sep || exit 1

	Only "$@"
	
	exit 0
fi

# exclude + both
if [ $OPTION -eq 51 ]; then
	Check_No_More_Opts "$@" || exit 1
	Check_Arg_Presented "$@" || exit 1
	Check_Subdir "$@" || exit 1
	Ask_Confirm "Are you sure you want to rename the entire directory tree under '$(pwd)' (excluding selected folders and their contents), with manual renaming required for each directory and file containing non-ASCII characters in their names? (y/n): " || exit 1
	Ask_Sep || exit 1

	Exclude "$@"
	
	exit 0
fi

# help
if [ $OPTION -eq 6 ]; then
	Check_No_More_Opts "$@" || exit 1
	Check_No_Args "$@" || exit 1
	Show_Help

	# TODO: action
fi
