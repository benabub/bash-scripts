#!/bin/bash
set -euo pipefail

# ========================================================
# FUNCTIONAL OVERVIEW
# ========================================================

# This script removes unwanted video segments based on provided timecodes.
# It offers a hybrid approach compared to traditional video editors:
#
# ADVANTAGES:
# - Lossless processing - Unlike editors that require full re-encoding,
#   this script performs lossless cutting (supports MP4, MOV, MKV, AVI, WMV, FLV, WebM).
#   No re-encoding preserves original quality and typically results in smaller output files.
# - Faster than full re-encoding - Processing time depends on number of cuts rather than video duration.
# - Format flexibility: Works natively with your source format without conversion.
#
# LIMITATIONS:
# - Potential visual artifacts at cut points - Since the script doesn't re-encode or re-create keyframes,
#   you may experience brief freezes or glitches at segment boundaries while the video stream 
#   catches up to the next keyframe. Audio transitions remain seamless.
# - Performance decreases with many segments - Each cut requires separate processing operations.
#
# Timecode Specifications:
# - Plaintext file (with/without extension).
# - Each line contains space-separated timecode pairs.
# - Accepted formats: 00:00:00 | 00:00:00.00 | 00:00:00:00.
# - Ordered top-to-bottom.
# - Use `None` | `none` | `False` | `false` when cutting from start/to end.
#
# Requirement: ffmpeg must be installed.

# ========================================================
# VARS
# ========================================================

input_video_file=$1
time_codes=$2
list_file="listemalissimo.txt"
part_1_file="particulipto_one.mp4"
part_2_file="particulipto_two.mp4"
temp_result="temp_result.mp4"

# ========================================================
# FUNCTIONS
# ========================================================

# Takes 1 arg: object name
Check_Extension() {
	local name="$1"
	local regex='^.+\.[a-zA-Z0-9\-]+$'
	if [[ "$name" =~ $regex ]]; then
		return 0
	else
		return 1
	fi
}

cleanup() {
    rm -f "$list_file" "$part_1_file" "$part_2_file" "$temp_result" 2>/dev/null
}

# ffmpeg check
run_ffmpeg() {
	if ! ffmpeg -nostdin -y "$@"; then
		echo "Error: ffmpeg command failed: $*"
		cleanup
		exit 1
	fi
}

fix_time_format() {
	local time_str=$1

	# check 00:00:00:00
	if [[ $time_str =~ ^([0-9]{2}:){3}[0-9]{2}$ ]]; then
		echo "${time_str%:*}.${time_str##*:}"

	# check 00:00:00
	elif [[ $time_str =~ ^([0-9]{2}:){2}[0-9]{2}$ ]]; then
		echo "$time_str"

	# check 00:00:00.00
	elif [[ $time_str =~ ^([0-9]{2}:){2}[0-9]{2}\.[0-9]{2}$ ]]; then
		echo "$time_str"

	# check [None, none, False, false]
	elif [[ "$time_str" == "None" || "$time_str" == "none" || "$time_str" == "False" || "$time_str" == "false" ]]; then
		echo "$time_str"

	else
		echo "Error: incorrect time format '$time_str' in timecodes file." >&2
		return 1
	fi
}

check_filename() {
    local base_name="$1"
    local extension=""
    local index=1
    local final_name="$base_name"

    if Check_Extension "$base_name"; then
        extension=".${base_name##*.}"
        base_name="${base_name%.*}"
    fi

    while [ -f "$final_name" ]; do
        final_name="${base_name}_${index}${extension}"
        ((index++))
    done

    echo "$final_name"
}

# ========================================================
# LOGIC
# ========================================================

# ------------------------------------------
# initial tests
# ------------------------------------------

if [ ! -f "$input_video_file" ]; then
    echo "Error: Input video file not found: $input_video_file"
    exit 1
fi

if [ ! -f "$time_codes" ]; then
    echo "Error: Time codes file not found: $time_codes"
    exit 1
fi

if ! command -v ffmpeg &> /dev/null; then
    echo "Error: ffmpeg is not installed"
    exit 1
fi

# ------------------------------------------
# all temp files names checking
# ------------------------------------------

list_file=$(check_filename "$list_file")
part_1_file=$(check_filename "$part_1_file")
part_2_file=$(check_filename "$part_2_file")
temp_result=$(check_filename "$temp_result")

# ------------------------------------------
# forming output file name
# ------------------------------------------

if Check_Extension "$input_video_file"; then
	extension=".${input_video_file##*.}"
else
	extension=""
fi

if [ -z "${3:-}" ]; then
	base_name="video_output"
else
	base_name="$3"
fi

output_video_file=$(check_filename "${base_name}${extension}")

# ------------------------------------------
# creating output file
# ------------------------------------------

cp -f "$input_video_file" "$output_video_file" || ( echo "Error: cannot copy $input_video_file"; exit 1 )

# ------------------------------------------
# temp file for ffmpeg -f concat command
# ------------------------------------------

printf "file '%s'\n" "$part_1_file" "$part_2_file" > "$list_file"

# ------------------------------------------
# cleanup temps
# ------------------------------------------

trap cleanup EXIT INT TERM

# ------------------------------------------
# reading timecodes recursevely - working cycle
# ------------------------------------------

tac "$time_codes" | while read -r line; do

	# left emty lines
	[[ -z "$line" ]] && continue

	# get data from line
	start_time=$(echo "$line" | awk '{print $1}')
	start_time=$(fix_time_format "$start_time")
	end_time=$(echo "$line" | awk '{print $2}')
	end_time=$(fix_time_format "$end_time")

	if [[ "$start_time" == "None" || "$start_time" == "none" || "$start_time" == "False" || "$start_time" == "false" ]]; then
		run_ffmpeg -i "$output_video_file" -ss "$end_time" -c copy "$temp_result"
		mv "$temp_result" "$output_video_file"

	elif [[ "$end_time" == "None" || "$end_time" == "none" || "$end_time" == "False" || "$end_time" == "false" ]]; then
		run_ffmpeg -i "$output_video_file" -to "$start_time" -c copy "$temp_result"
		mv "$temp_result" "$output_video_file"
	else
		run_ffmpeg -i "$output_video_file" -to "$start_time" -c copy "$part_1_file"
		run_ffmpeg -i "$output_video_file" -ss "$end_time" -c copy "$part_2_file"
		run_ffmpeg -f concat -safe 0 -i "$list_file" -c copy "$temp_result"
		mv "$temp_result" "$output_video_file"
	fi
done
